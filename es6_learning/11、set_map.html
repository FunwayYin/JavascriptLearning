<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>set map</title>
</head>
<body>
<script type="application/javascript">
    // 1 Set
        //  const s = new Set();
        //  [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
        //    for (let i of s) {
        //    console.log(i);
        //  }
        //  2 3 5 4
        //  结果表明 Set 结构不会添加重复的值。

        // 例一
        // const a = new Set([1, 2, 3, 4, 4]);
        // console.log([...a]);
        // [1, 2, 3, 4]

        // 例二
        // const b = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
        // console.log(b.size);
        // 5

        // let set = new Set();
        // let a = NaN;
        // let b = NaN;
        // set.add(a);
        // set.add(b);
        // console.log(set);
        // Set {NaN}
        // 上面代码向 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等。

        // let set = new Set();
        //
        // set.add({});
        // console.log(set.size);
        // 1

        // set.add({});
        // console.log(set.size);
        // 2

        // ['red', 'green', 'blue']
        // keys()：返回键名的遍历器
        // values()：返回键值的遍历器
        // entries()：返回键值对的遍历器
        // forEach()：使用回调函数遍历每个成员

        // Set.prototype.constructor：构造函数，默认就是Set函数。
        // Set.prototype.size：返回Set实例的成员总数。
        // add(value)：添加某个值，返回 Set 结构本身。
        // delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
        // has(value)：返回一个布尔值，表示该值是否为Set的成员。
        // clear()：清除所有成员，没有返回值。

        // let s = new Set();
        // s.add(1).add(2).add(2);    // 注意2被加入了两次
        //
        // console.log(s.size);      // 2
        // console.log(s.has(1));    // true
        // console.log(s.has(2));    // true
        // console.log(s.has(3));    // false
        //
        // console.log(s.delete(2));
        // console.log(s.has(2));    // false

        // 对象的写法
        // const  a= {
        //     'width': 1,
        //     'height': 1
        // };
        // if (a['width']) {
        //     console.log(a[ 'width']);
        // }

        // Set的写法
        // const b = new Set();
        // b.add('width');
        // b.add('height');
        // if (b.has('width')) {
        //     console.log(b.keys());
        // }

        // const items = new Set([1, 2, 3, 4,4,2,3,4,5, 5]);
        // const array = Array.from(items);
        //Array.from方法可以将 Set 结构转为数组。

        //这就提供了去除数组重复成员的另一种方法。
        //先将数组变成set并且自动去重，再使用Array.from变成数组
        // function dedupe(array) {
        //     return Array.from(new Set(array));
        // };
        // console.log(dedupe(array));
        // [1, 2, 3]

        //扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构
        // let set = new Set(['red', 'green', 'blue']);
        // let arr = [...set];
        // console.log(arr);
        // ["red", "green", "blue"]

        //扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。
        // let arr = [3, 5, 2, 2, 5, 5];
        // let unique = [...new Set(arr)];
        // console.log(unique);

        // let a = new Set([1, 2, 3]);
        // let b = new Set([4, 3, 2]);

        // 并集
        // let union = new Set([...a, ...b]);
        // console.log(union);
        // Set {1, 2, 3, 4}

        // 交集
        // let intersect = new Set([...a].filter(x => b.has(x)));
        // console.log(intersect);
        // set {2, 3}

        // 差集
        // let difference = Array.from(union).filter(
        //     x => !intersect.has(x)
        // );
        // console.log(difference);
        // set {1 4 }

        // 方法一
        // let set = new Set([1, 2, 3]);
        // set = new Set([...set].map(val => val * 2));
        // console.log(set);

        // 方法二
        // let set = new Set([1, 2, 3]);
        // set = new Set(Array.from(set, val => val * 2));

        // set的值是2, 4, 6

    // 2 WeakSet

        // 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。
        // 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，
        // 也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
        // 这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。
        // 结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。
        // WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。
        // 因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。
        // 只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。
        // 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。
        // 另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，
        // 因此 ES6 规定 WeakSet 不可遍历。

        // const ws = new WeakSet();
        // const obj = {};
        // const foo = {};
        //
        // console.log(ws.add(window));     // true
        // console.log(ws.add(obj));        // true
        //
        // console.log(ws.has(window));    // true
        // console.log(ws.has(foo));       // false
        //
        // console.log(ws.delete(window));
        // console.log(ws.has(window));    // false

        // WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。
        // WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。
        // const foos = new WeakSet();
        // class Foo {
        //     constructor() {
        //         foos.add(this)
        //     }
        //     method () {
        //         if (!foos.has(this)) {
        //             throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');
        //         }
        //         console.log(" foo method is used ");
        //     }
        // }
        //
        // let f = new Foo();
        // f.method();
        // foo method is used

        // 上面代码保证了Foo的实例方法，只能在Foo的实例上调用。
        // 这里使用 WeakSet 的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。

    // 3 Map

        // const m = new Map();
        // const o = {p: 'Hello World'};
        //
        // console.log(m.set(o, 'content'));
        // console.log(m.get(o));              // "content"
        //
        // console.log(m.has(o));              // true
        // console.log(m.delete(o));           // true
        // console.log(m.has(o));              // false

        // const map = new Map([
        //     ['name', '张三'],
        //     ['title', 'Author']
        // ]);
        //
        // map.size; // 2
        // map.has('name');  // true
        // map.get('name');  // "张三"
        // map.has('title'); // true
        // map.get('title'); // "Author"

        // 不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。
        // 这就是说，Set和Map都可以用来生成新的 Map。

        // const set = new Set([
        //     ['foo', 1],
        //     ['bar', 2]
        // ]);
        // const m1 = new Map(set);
        // m1.get('foo');
        // 1

        // const m2 = new Map([
        //     ['baz', 3]
        // ]);
        // const m3 = new Map(m2);
        // m3.get('baz')
        // 3

        // const map = new Map();
        // map.set(['a'], 555);
        // console.log(map.get(['a']));
        // undefined
        // 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。

        // const map = new Map();
        // const k1 = ['a'];
        // const k2 = ['b'];
        // map.set(k1, 111).set(k2, 222);
        // console.log(map.get(k1)); // 111
        // console.log(map.get(k2)); // 222

        // let map = new Map();
        //
        // map.set(-0, 123);
        // map.get(+0) // 123
        //
        // map.set(true, 1);
        // map.set('true', 2);
        // map.get(true) // 1
        //
        // map.set(undefined, 3);
        // map.set(null, 4);
        // map.get(undefined) // 3
        //
        // map.set(NaN, 123);
        // map.get(NaN) // 123

        // Map 结构的实例有以下属性和操作方法。
        // size();
        // set();
        // get();
        // has();
        // delete();
        // clear();

        // Map 结构原生提供三个遍历器生成函数和一个遍历方法。
        // keys()：返回键名的遍历器。
        // values()：返回键值的遍历器。
        // entries()：返回所有成员的遍历器。
        // forEach()：遍历 Map 的所有成员。
        // map[Symbol.iterator] === map.entries  // true

        // Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。

        // const map = new Map([
        //     [1, 'one'],
        //     [2, 'two'],
        //     [3, 'three'],
        // ]);
        //
        // [...map.keys()]
        // // [1, 2, 3]
        //
        // [...map.values()]
        // ['one', 'two', 'three']
        //
        // [...map.entries()]
        // [[1,'one'], [2, 'two'], [3, 'three']]
        //
        // [...map]
        // [[1,'one'], [2, 'two'], [3, 'three']]

        // const map0 = new Map()
        //     .set(1, 'a')
        //     .set(2, 'b')
        //     .set(3, 'c');
        //
        // const map1 = new Map(
        //     [...map0].filter(([k, v]) => k < 3)
        // );
        // console.log(map1);
        // 产生 Map 结构 {1 => 'a', 2 => 'b'}

        // const map2 = new Map(
        //     [...map0].map(([k, v]) => [k * 2, '_' + v])
        // );
        // console.log(map2);
        // 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}

        // const map = new Map()
        //     .set(1, 'a')
        //     .set(2, 'b')
        //     .set(3, 'c');
        // const reporter = {
        //     report: function(key, value) {
        //         console.log("Key: %s, Value: %s", key, value);
        //     }
        // };
        // map.forEach(function(value, key) {
        //     this.report(key, value);
        // }, reporter);
        //上面代码中，forEach方法的回调函数的this，就指向reporter。


   // 4 WeakMap
        // WeakMap与Map的区别有两点。
        // 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
            // const map = new WeakMap();
            // map.set(1, 2)
            // TypeError: 1 is not an object!
            // map.set(Symbol(), 2)
            // TypeError: Invalid value used as weak map key
            // map.set(null, 2)
            // TypeError: Invalid value used as weak map key

        // WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。
        // 因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。
        // 也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

        // 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。
        // 一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。
        // 当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。

        // const wm = new WeakMap();
        // const element = document.getElementById('example');
        // wm.set(element, 'some information');
        // wm.get(element)
        // "some information"

        // WeakMap 与 Map 在 API 上的区别主要是两个，

        // 一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。
        // 因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。
        // 这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。

        // 二是无法清空，即不支持clear方法。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。

        const _counter = new WeakMap();
        const _action  = new WeakMap();
        class Countdown {
            constructor(counter, action) {
                _counter.set(this, counter);
                _action.set(this, action);
            }
            dec() {
                let counter = _counter.get(this);
                if (counter < 1){
                    return;
                }
                counter--;

                _counter.set(this, counter);

                if (counter === 0) {
                    _action.get(this)();
                }

            }
        }
        // const c = new Countdown(2, () => console.log('DONE'));
        // console.log(c.dec());
        // console.log(c.dec());

        // undefined
        // DONE
        // undefined

        // 上面代码中，Countdown类的两个内部属性_counter和_action，是实例的弱引用，
        // 所以如果删除实例，它们也就随之消失，不会造成内存泄漏。



</script>
</body>
</html>